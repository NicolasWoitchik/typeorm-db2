{"version":3,"sources":["../browser/src/query-builder/SelectQueryBuilder.ts"],"names":[],"mappings":"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","file":"SelectQueryBuilder.js","sourcesContent":["import { SapDriver } from \"../driver/sap/SapDriver\";\nimport { RawSqlResultsToEntityTransformer } from \"./transformer/RawSqlResultsToEntityTransformer\";\nimport { ObjectLiteral } from \"../common/ObjectLiteral\";\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\";\nimport { PessimisticLockTransactionRequiredError } from \"../error/PessimisticLockTransactionRequiredError\";\nimport { NoVersionOrUpdateDateColumnError } from \"../error/NoVersionOrUpdateDateColumnError\";\nimport { OptimisticLockVersionMismatchError } from \"../error/OptimisticLockVersionMismatchError\";\nimport { OptimisticLockCanNotBeUsedError } from \"../error/OptimisticLockCanNotBeUsedError\";\nimport { JoinAttribute } from \"./JoinAttribute\";\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\";\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\";\nimport { RelationIdLoader } from \"./relation-id/RelationIdLoader\";\nimport { RelationIdMetadataToAttributeTransformer } from \"./relation-id/RelationIdMetadataToAttributeTransformer\";\nimport { RelationCountLoader } from \"./relation-count/RelationCountLoader\";\nimport { RelationCountMetadataToAttributeTransformer } from \"./relation-count/RelationCountMetadataToAttributeTransformer\";\nimport { QueryBuilder } from \"./QueryBuilder\";\nimport { ReadStream } from \"../platform/PlatformTools\";\nimport { LockNotSupportedOnGivenDriverError } from \"../error/LockNotSupportedOnGivenDriverError\";\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\";\nimport { PostgresDriver } from \"../driver/postgres/PostgresDriver\";\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\";\nimport { SelectQuery } from \"./SelectQuery\";\nimport { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { OrderByCondition } from \"../find-options/OrderByCondition\";\nimport { QueryExpressionMap } from \"./QueryExpressionMap\";\nimport { EntityTarget } from \"../common/EntityTarget\";\nimport { QueryRunner } from \"../query-runner/QueryRunner\";\nimport { WhereExpression } from \"./WhereExpression\";\nimport { Brackets } from \"./Brackets\";\nimport { AbstractSqliteDriver } from \"../driver/sqlite-abstract/AbstractSqliteDriver\";\nimport { QueryResultCacheOptions } from \"../cache/QueryResultCacheOptions\";\nimport { OffsetWithoutLimitNotSupportedError } from \"../error/OffsetWithoutLimitNotSupportedError\";\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\";\nimport { SelectQueryBuilderOption } from \"./SelectQueryBuilderOption\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { AuroraDataApiDriver } from \"../driver/aurora-data-api/AuroraDataApiDriver\";\nimport { CockroachDriver } from \"../driver/cockroachdb/CockroachDriver\";\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\";\nimport { DB2Driver } from \"../driver/db2/DB2Driver\";\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SelectQueryBuilder<Entity>\n    extends QueryBuilder<Entity>\n    implements WhereExpression {\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated sql query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createComment();\n        sql += this.createSelectExpression();\n        sql += this.createJoinExpression();\n        sql += this.createWhereExpression();\n        sql += this.createGroupByExpression();\n        sql += this.createHavingExpression();\n        sql += this.createOrderByExpression();\n        sql += this.createLimitOffsetExpression();\n        sql += this.createLockExpression();\n        sql = sql.trim();\n        if (this.expressionMap.subQuery) sql = \"(\" + sql + \")\";\n        return sql;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a subquery - query that can be used inside other queries.\n     */\n    subQuery(): SelectQueryBuilder<any> {\n        const qb = this.createQueryBuilder();\n        qb.expressionMap.subQuery = true;\n        qb.expressionMap.parentQueryBuilder = this;\n        return qb;\n    }\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(): this;\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        selectionAliasName?: string\n    ): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string, selectionAliasName?: string): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string[]): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection?:\n            | string\n            | string[]\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        selectionAliasName?: string\n    ): SelectQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"select\";\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = selection.map((selection) => ({\n                selection: selection,\n            }));\n        } else if (selection instanceof Function) {\n            const subQueryBuilder = selection(this.subQuery());\n            this.setParameters(subQueryBuilder.getParameters());\n            this.expressionMap.selects.push({\n                selection: subQueryBuilder.getQuery(),\n                aliasName: selectionAliasName,\n            });\n        } else if (selection) {\n            this.expressionMap.selects = [\n                { selection: selection, aliasName: selectionAliasName },\n            ];\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(\n        selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        selectionAliasName?: string\n    ): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string, selectionAliasName?: string): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string[]): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(\n        selection:\n            | string\n            | string[]\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        selectionAliasName?: string\n    ): this {\n        if (!selection) return this;\n\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = this.expressionMap.selects.concat(\n                selection.map((selection) => ({ selection: selection }))\n            );\n        } else if (selection instanceof Function) {\n            const subQueryBuilder = selection(this.subQuery());\n            this.setParameters(subQueryBuilder.getParameters());\n            this.expressionMap.selects.push({\n                selection: subQueryBuilder.getQuery(),\n                aliasName: selectionAliasName,\n            });\n        } else if (selection) {\n            this.expressionMap.selects.push({\n                selection: selection,\n                aliasName: selectionAliasName,\n            });\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets whether the selection is DISTINCT.\n     */\n    distinct(distinct: boolean = true): this {\n        this.expressionMap.selectDistinct = distinct;\n        return this;\n    }\n\n    /**\n     * Sets the distinct on clause for Postgres.\n     */\n    distinctOn(distinctOn: string[]): this {\n        this.expressionMap.selectDistinctOn = distinctOn;\n        return this;\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T>(\n        entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        aliasName: string\n    ): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T>(\n        entityTarget: EntityTarget<T>,\n        aliasName: string\n    ): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T>(\n        entityTarget:\n            | EntityTarget<T>\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string\n    ): SelectQueryBuilder<T> {\n        const mainAlias = this.createFromAlias(entityTarget, aliasName);\n        this.expressionMap.setMainAlias(mainAlias);\n        return (this as any) as SelectQueryBuilder<T>;\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T>(\n        entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        aliasName: string\n    ): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T>(\n        entityTarget: EntityTarget<T>,\n        aliasName: string\n    ): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T>(\n        entityTarget:\n            | EntityTarget<T>\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string\n    ): SelectQueryBuilder<T> {\n        const alias = this.createFromAlias(entityTarget, aliasName);\n        if (!this.expressionMap.mainAlias)\n            this.expressionMap.setMainAlias(alias);\n\n        return (this as any) as SelectQueryBuilder<T>;\n    }\n\n    /**\n     * INNER JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs (without selection) given entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs (without selection) entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * INNER JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.addSelect(alias);\n        this.innerJoin(entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        entity: Function | string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.addSelect(alias);\n        this.leftJoin(entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.addSelect(alias);\n        this.join(\n            \"INNER\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            true\n        );\n        return this;\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.addSelect(alias);\n        this.join(\n            \"INNER\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            false\n        );\n        return this;\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.addSelect(alias);\n        this.join(\n            \"LEFT\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            true\n        );\n        return this;\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.addSelect(alias);\n        this.join(\n            \"LEFT\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            false\n        );\n        return this;\n    }\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, property: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entity: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, tableName: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entityOrProperty: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this {\n    //     const select = new SelectAttribute(this.expressionMap);\n    //     select.mapToProperty = mapToProperty;\n    //     select.entityOrProperty = entityOrProperty;\n    //     select.aliasName = aliasName;\n    //     select.qbFactory = qbFactory;\n    //     return this;\n    // }\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        options?: { disableMixedMap?: boolean }\n    ): this;\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        alias: string,\n        queryBuilderFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>\n    ): this;\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        aliasNameOrOptions?: string | { disableMixedMap?: boolean },\n        queryBuilderFactory?: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>\n    ): this {\n        const relationIdAttribute = new RelationIdAttribute(this.expressionMap);\n        relationIdAttribute.mapToProperty = mapToProperty;\n        relationIdAttribute.relationName = relationName;\n        if (typeof aliasNameOrOptions === \"string\")\n            relationIdAttribute.alias = aliasNameOrOptions;\n        if (\n            aliasNameOrOptions instanceof Object &&\n            (aliasNameOrOptions as any).disableMixedMap\n        )\n            relationIdAttribute.disableMixedMap = true;\n\n        relationIdAttribute.queryBuilderFactory = queryBuilderFactory;\n        this.expressionMap.relationIdAttributes.push(relationIdAttribute);\n\n        if (relationIdAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationIdAttribute.junctionAlias,\n                metadata: relationIdAttribute.relation.junctionEntityMetadata,\n            });\n        }\n        return this;\n    }\n\n    /**\n     * Counts number of entities of entity's relation and maps the value into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationCountAndMap(\n        mapToProperty: string,\n        relationName: string,\n        aliasName?: string,\n        queryBuilderFactory?: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>\n    ): this {\n        const relationCountAttribute = new RelationCountAttribute(\n            this.expressionMap\n        );\n        relationCountAttribute.mapToProperty = mapToProperty;\n        relationCountAttribute.relationName = relationName;\n        relationCountAttribute.alias = aliasName;\n        relationCountAttribute.queryBuilderFactory = queryBuilderFactory;\n        this.expressionMap.relationCountAttributes.push(relationCountAttribute);\n\n        this.expressionMap.createAlias({\n            type: \"other\",\n            name: relationCountAttribute.junctionAlias,\n        });\n        if (relationCountAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationCountAttribute.junctionAlias,\n                metadata:\n                    relationCountAttribute.relation.junctionEntityMetadata,\n            });\n        }\n        return this;\n    }\n\n    /**\n     * Loads all relation ids for all relations of the selected entity.\n     * All relation ids will be mapped to relation property themself.\n     * If array of strings is given then loads only relation ids of the given properties.\n     */\n    loadAllRelationIds(options?: {\n        relations?: string[];\n        disableMixedMap?: boolean;\n    }): this {\n        // todo: add skip relations\n        this.expressionMap.mainAlias!.metadata.relations.forEach((relation) => {\n            if (\n                options !== undefined &&\n                options.relations !== undefined &&\n                options.relations.indexOf(relation.propertyPath) === -1\n            )\n                return;\n\n            this.loadRelationIdAndMap(\n                this.expressionMap.mainAlias!.name +\n                    \".\" +\n                    relation.propertyPath,\n                this.expressionMap.mainAlias!.name +\n                    \".\" +\n                    relation.propertyPath,\n                options\n            );\n        });\n        return this;\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(\n        where:\n            | Brackets\n            | string\n            | ((qb: this) => string)\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral\n    ): this {\n        this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.computeWhereParameter(where);\n        if (condition)\n            this.expressionMap.wheres = [\n                { type: \"simple\", condition: condition },\n            ];\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(\n        where: string | Brackets | ((qb: this) => string),\n        parameters?: ObjectLiteral\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"and\",\n            condition: this.computeWhereParameter(where),\n        });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(\n        where: Brackets | string | ((qb: this) => string),\n        parameters?: ObjectLiteral\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"or\",\n            condition: this.computeWhereParameter(where),\n        });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    whereInIds(ids: any | any[]): this {\n        return this.where(this.createWhereIdsExpression(ids));\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    andWhereInIds(ids: any | any[]): this {\n        return this.andWhere(this.createWhereIdsExpression(ids));\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    orWhereInIds(ids: any | any[]): this {\n        return this.orWhere(this.createWhereIdsExpression(ids));\n    }\n\n    /**\n     * Sets HAVING condition in the query builder.\n     * If you had previously HAVING expression defined,\n     * calling this function will override previously set HAVING conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    having(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"simple\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"and\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new OR HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"or\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(): this;\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy: string): this;\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy?: string): this {\n        if (groupBy) {\n            this.expressionMap.groupBys = [groupBy];\n        } else {\n            this.expressionMap.groupBys = [];\n        }\n        return this;\n    }\n\n    /**\n     * Adds GROUP BY condition in the query builder.\n     */\n    addGroupBy(groupBy: string): this {\n        this.expressionMap.groupBys.push(groupBy);\n        return this;\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort: string,\n        order?: \"ASC\" | \"DESC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\"\n    ): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort?: string | OrderByCondition,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\"\n    ): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new Error(\n                `SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`\n            );\n        if (\n            nulls !== undefined &&\n            nulls !== \"NULLS FIRST\" &&\n            nulls !== \"NULLS LAST\"\n        )\n            throw new Error(\n                `SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`\n            );\n\n        if (sort) {\n            if (sort instanceof Object) {\n                this.expressionMap.orderBys = sort as OrderByCondition;\n            } else {\n                if (nulls) {\n                    this.expressionMap.orderBys = {\n                        [sort as string]: { order, nulls },\n                    };\n                } else {\n                    this.expressionMap.orderBys = { [sort as string]: order };\n                }\n            }\n        } else {\n            this.expressionMap.orderBys = {};\n        }\n        return this;\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(\n        sort: string,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\"\n    ): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new Error(\n                `SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`\n            );\n        if (\n            nulls !== undefined &&\n            nulls !== \"NULLS FIRST\" &&\n            nulls !== \"NULLS LAST\"\n        )\n            throw new Error(\n                `SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`\n            );\n\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls };\n        } else {\n            this.expressionMap.orderBys[sort] = order;\n        }\n        return this;\n    }\n\n    /**\n     * Set's LIMIT - maximum number of rows to be selected.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead take method instead.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = this.normalizeNumber(limit);\n        if (\n            this.expressionMap.limit !== undefined &&\n            isNaN(this.expressionMap.limit)\n        )\n            throw new Error(\n                `Provided \"limit\" value is not a number. Please provide a numeric value.`\n            );\n\n        return this;\n    }\n\n    /**\n     * Set's OFFSET - selection offset.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead skip method instead.\n     */\n    offset(offset?: number): this {\n        this.expressionMap.offset = this.normalizeNumber(offset);\n        if (\n            this.expressionMap.offset !== undefined &&\n            isNaN(this.expressionMap.offset)\n        )\n            throw new Error(\n                `Provided \"offset\" value is not a number. Please provide a numeric value.`\n            );\n\n        return this;\n    }\n\n    /**\n     * Sets maximal number of entities to take.\n     */\n    take(take?: number): this {\n        this.expressionMap.take = this.normalizeNumber(take);\n        if (\n            this.expressionMap.take !== undefined &&\n            isNaN(this.expressionMap.take)\n        )\n            throw new Error(\n                `Provided \"take\" value is not a number. Please provide a numeric value.`\n            );\n\n        return this;\n    }\n\n    /**\n     * Sets number of entities to skip.\n     */\n    skip(skip?: number): this {\n        this.expressionMap.skip = this.normalizeNumber(skip);\n        if (\n            this.expressionMap.skip !== undefined &&\n            isNaN(this.expressionMap.skip)\n        )\n            throw new Error(\n                `Provided \"skip\" value is not a number. Please provide a numeric value.`\n            );\n\n        return this;\n    }\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"optimistic\", lockVersion: number): this;\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"optimistic\", lockVersion: Date): this;\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(\n        lockMode:\n            | \"pessimistic_read\"\n            | \"pessimistic_write\"\n            | \"dirty_read\"\n            | \"pessimistic_partial_write\"\n            | \"pessimistic_write_or_fail\"\n            | \"for_no_key_update\"\n    ): this;\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(\n        lockMode:\n            | \"optimistic\"\n            | \"pessimistic_read\"\n            | \"pessimistic_write\"\n            | \"dirty_read\"\n            | \"pessimistic_partial_write\"\n            | \"pessimistic_write_or_fail\"\n            | \"for_no_key_update\",\n        lockVersion?: number | Date\n    ): this {\n        this.expressionMap.lockMode = lockMode;\n        this.expressionMap.lockVersion = lockVersion;\n        return this;\n    }\n\n    /**\n     * Disables the global condition of \"non-deleted\" for the entity with delete date columns.\n     */\n    withDeleted(): this {\n        this.expressionMap.withDeleted = true;\n        return this;\n    }\n\n    /**\n     * Gets first raw result returned by execution of generated query builder sql.\n     */\n    async getRawOne<T = any>(): Promise<T> {\n        return (await this.getRawMany())[0];\n    }\n\n    /**\n     * Gets all raw results returned by execution of generated query builder sql.\n     */\n    async getRawMany<T = any>(): Promise<T[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        this.expressionMap.queryEntity = false;\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            const results = await this.loadRawResults(queryRunner);\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) {}\n            }\n            throw error;\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release();\n            }\n        }\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    async getRawAndEntities<T = any>(): Promise<{\n        entities: Entity[];\n        raw: T[];\n    }> {\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            this.expressionMap.queryEntity = true;\n            const results = await this.executeEntitiesAndRawResults(\n                queryRunner\n            );\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) {}\n            }\n            throw error;\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Gets single entity returned by execution of generated query builder sql.\n     */\n    async getOne(): Promise<Entity | undefined> {\n        const results = await this.getRawAndEntities();\n        const result = results.entities[0] as any;\n\n        if (\n            result &&\n            this.expressionMap.lockMode === \"optimistic\" &&\n            this.expressionMap.lockVersion\n        ) {\n            const metadata = this.expressionMap.mainAlias!.metadata;\n\n            if (this.expressionMap.lockVersion instanceof Date) {\n                const actualVersion = metadata.updateDateColumn!.getEntityValue(\n                    result\n                ); // what if columns arent set?\n                if (\n                    actualVersion.getTime() !==\n                    this.expressionMap.lockVersion.getTime()\n                )\n                    throw new OptimisticLockVersionMismatchError(\n                        metadata.name,\n                        this.expressionMap.lockVersion,\n                        actualVersion\n                    );\n            } else {\n                const actualVersion = metadata.versionColumn!.getEntityValue(\n                    result\n                ); // what if columns arent set?\n                if (actualVersion !== this.expressionMap.lockVersion)\n                    throw new OptimisticLockVersionMismatchError(\n                        metadata.name,\n                        this.expressionMap.lockVersion,\n                        actualVersion\n                    );\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.\n     */\n    async getOneOrFail(): Promise<Entity> {\n        const entity = await this.getOne();\n\n        if (!entity) {\n            throw new EntityNotFoundError(\n                this.expressionMap.mainAlias!.target,\n                this\n            );\n        }\n\n        return entity;\n    }\n\n    /**\n     * Gets entities returned by execution of generated query builder sql.\n     */\n    async getMany(): Promise<Entity[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const results = await this.getRawAndEntities();\n        return results.entities;\n    }\n\n    /**\n     * Gets count - number of entities selected by sql generated by this query builder.\n     * Count excludes all limitations set by setFirstResult and setMaxResults methods call.\n     */\n    async getCount(): Promise<number> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            this.expressionMap.queryEntity = false;\n            const results = await this.executeCountQuery(queryRunner);\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) {}\n            }\n            throw error;\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns entities and overall entities count (without limitation).\n     * This method is useful to build pagination.\n     */\n    async getManyAndCount(): Promise<[Entity[], number]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            this.expressionMap.queryEntity = true;\n            const entitiesAndRaw = await this.executeEntitiesAndRawResults(\n                queryRunner\n            );\n            this.expressionMap.queryEntity = false;\n            const count = await this.executeCountQuery(queryRunner);\n            const results: [Entity[], number] = [\n                entitiesAndRaw.entities,\n                count,\n            ];\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) {}\n            }\n            throw error;\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns raw data stream.\n     */\n    async stream(): Promise<ReadStream> {\n        this.expressionMap.queryEntity = false;\n        const [sql, parameters] = this.getQueryAndParameters();\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            const releaseFn = () => {\n                if (queryRunner !== this.queryRunner)\n                    // means we created our own query runner\n                    return queryRunner.release();\n                return;\n            };\n            const results = queryRunner.stream(\n                sql,\n                parameters,\n                releaseFn,\n                releaseFn\n            );\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) {}\n            }\n            throw error;\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(enabled: boolean): this;\n\n    /**\n     * Enables query result caching and sets in milliseconds in which cache will expire.\n     * If not set then global caching time will be used.\n     */\n    cache(milliseconds: number): this;\n\n    /**\n     * Enables query result caching and sets cache id and milliseconds in which cache will expire.\n     */\n    cache(id: any, milliseconds?: number): this;\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(\n        enabledOrMillisecondsOrId: boolean | number | string,\n        maybeMilliseconds?: number\n    ): this {\n        if (typeof enabledOrMillisecondsOrId === \"boolean\") {\n            this.expressionMap.cache = enabledOrMillisecondsOrId;\n        } else if (typeof enabledOrMillisecondsOrId === \"number\") {\n            this.expressionMap.cache = true;\n            this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;\n        } else if (\n            typeof enabledOrMillisecondsOrId === \"string\" ||\n            typeof enabledOrMillisecondsOrId === \"number\"\n        ) {\n            this.expressionMap.cache = true;\n            this.expressionMap.cacheId = enabledOrMillisecondsOrId;\n        }\n\n        if (maybeMilliseconds) {\n            this.expressionMap.cacheDuration = maybeMilliseconds;\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets extra options that can be used to configure how query builder works.\n     */\n    setOption(option: SelectQueryBuilderOption): this {\n        this.expressionMap.options.push(option);\n        return this;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected join(\n        direction: \"INNER\" | \"LEFT\",\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n        mapToProperty?: string,\n        isMappingMany?: boolean\n    ): void {\n        this.setParameters(parameters || {});\n\n        const joinAttribute = new JoinAttribute(\n            this.connection,\n            this.expressionMap\n        );\n        joinAttribute.direction = direction;\n        joinAttribute.mapToProperty = mapToProperty;\n        joinAttribute.isMappingMany = isMappingMany;\n        joinAttribute.entityOrProperty = entityOrProperty; // relationName\n        joinAttribute.condition = condition; // joinInverseSideCondition\n        // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\n        this.expressionMap.joinAttributes.push(joinAttribute);\n\n        if (joinAttribute.metadata) {\n            // todo: find and set metadata right there?\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                metadata: joinAttribute.metadata,\n            });\n            if (\n                joinAttribute.relation &&\n                joinAttribute.relation.junctionEntityMetadata\n            ) {\n                this.expressionMap.createAlias({\n                    type: \"join\",\n                    name: joinAttribute.junctionAlias,\n                    metadata: joinAttribute.relation.junctionEntityMetadata,\n                });\n            }\n        } else {\n            let subQuery: string = \"\";\n            if (entityOrProperty instanceof Function) {\n                const subQueryBuilder: SelectQueryBuilder<any> = (entityOrProperty as any)(\n                    ((this as any) as SelectQueryBuilder<any>).subQuery()\n                );\n                this.setParameters(subQueryBuilder.getParameters());\n                subQuery = subQueryBuilder.getQuery();\n            } else {\n                subQuery = entityOrProperty;\n            }\n            const isSubQuery =\n                entityOrProperty instanceof Function ||\n                (entityOrProperty.substr(0, 1) === \"(\" &&\n                    entityOrProperty.substr(-1) === \")\");\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                tablePath:\n                    isSubQuery === false\n                        ? (entityOrProperty as string)\n                        : undefined,\n                subQuery: isSubQuery === true ? subQuery : undefined,\n            });\n        }\n    }\n\n    /**\n     * Creates \"SELECT FROM\" part of SQL query.\n     */\n    protected createSelectExpression() {\n        if (!this.expressionMap.mainAlias)\n            throw new Error(\n                \"Cannot build query because main alias is not set (call qb#from method)\"\n            );\n\n        // todo throw exception if selects or from is missing\n\n        const allSelects: SelectQuery[] = [];\n        const excludedSelects: SelectQuery[] = [];\n\n        if (this.expressionMap.mainAlias.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            allSelects.push(\n                ...this.buildEscapedEntityColumnSelects(\n                    this.expressionMap.mainAlias.name,\n                    metadata\n                )\n            );\n            excludedSelects.push(\n                ...this.findEntityColumnSelects(\n                    this.expressionMap.mainAlias.name,\n                    metadata\n                )\n            );\n        }\n\n        // add selects from joins\n        this.expressionMap.joinAttributes.forEach((join) => {\n            if (join.metadata) {\n                allSelects.push(\n                    ...this.buildEscapedEntityColumnSelects(\n                        join.alias.name!,\n                        join.metadata\n                    )\n                );\n                excludedSelects.push(\n                    ...this.findEntityColumnSelects(\n                        join.alias.name!,\n                        join.metadata\n                    )\n                );\n            } else {\n                const hasMainAlias = this.expressionMap.selects.some(\n                    (select) => select.selection === join.alias.name\n                );\n                if (hasMainAlias) {\n                    allSelects.push({\n                        selection: this.escape(join.alias.name!) + \".*\",\n                    });\n                    const excludedSelect = this.expressionMap.selects.find(\n                        (select) => select.selection === join.alias.name\n                    );\n                    excludedSelects.push(excludedSelect!);\n                }\n            }\n        });\n\n        // add all other selects\n        this.expressionMap.selects\n            .filter((select) => excludedSelects.indexOf(select) === -1)\n            .forEach((select) =>\n                allSelects.push({\n                    selection: this.replacePropertyNames(select.selection),\n                    aliasName: select.aliasName,\n                })\n            );\n\n        // if still selection is empty, then simply set it to all (*)\n        if (allSelects.length === 0) allSelects.push({ selection: \"*\" });\n\n        let lock: string = \"\";\n        if (this.connection.driver instanceof SqlServerDriver) {\n            switch (this.expressionMap.lockMode) {\n                case \"pessimistic_read\":\n                    lock = \" WITH (HOLDLOCK, ROWLOCK)\";\n                    break;\n                case \"pessimistic_write\":\n                    lock = \" WITH (UPDLOCK, ROWLOCK)\";\n                    break;\n                case \"dirty_read\":\n                    lock = \" WITH (NOLOCK)\";\n                    break;\n            }\n        }\n\n        // create a selection query\n        const froms = this.expressionMap.aliases\n            .filter(\n                (alias) =>\n                    alias.type === \"from\" && (alias.tablePath || alias.subQuery)\n            )\n            .map((alias) => {\n                if (alias.subQuery)\n                    return alias.subQuery + \" \" + this.escape(alias.name);\n\n                return (\n                    this.getTableName(alias.tablePath!) +\n                    \" \" +\n                    this.escape(alias.name)\n                );\n            });\n\n        const select = this.createSelectDistinctExpression();\n        const selection = allSelects\n            .map(\n                (select) =>\n                    select.selection +\n                    (select.aliasName\n                        ? \" AS \" + this.escape(select.aliasName)\n                        : \"\")\n            )\n            .join(\", \");\n\n        return select + selection + \" FROM \" + froms.join(\", \") + lock;\n    }\n\n    /**\n     * Creates select | select distinct part of SQL query.\n     */\n    protected createSelectDistinctExpression(): string {\n        const { selectDistinct, selectDistinctOn } = this.expressionMap;\n        const { driver } = this.connection;\n\n        let select = \"SELECT \";\n        if (driver instanceof PostgresDriver && selectDistinctOn.length > 0) {\n            const selectDistinctOnMap = selectDistinctOn\n                .map((on) => this.replacePropertyNames(on))\n                .join(\", \");\n\n            select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `;\n        } else if (selectDistinct) {\n            select = \"SELECT DISTINCT \";\n        }\n\n        return select;\n    }\n\n    /**\n     * Creates \"JOIN\" part of SQL query.\n     */\n    protected createJoinExpression(): string {\n        // examples:\n        // select from owning side\n        // qb.select(\"post\")\n        //     .leftJoinAndSelect(\"post.category\", \"category\");\n        // select from non-owning side\n        // qb.select(\"category\")\n        //     .leftJoinAndSelect(\"category.post\", \"post\");\n\n        const joins = this.expressionMap.joinAttributes.map((joinAttr) => {\n            const relation = joinAttr.relation;\n            const destinationTableName = joinAttr.tablePath;\n            const destinationTableAlias = joinAttr.alias.name;\n            const appendedCondition = joinAttr.condition\n                ? \" AND (\" + joinAttr.condition + \")\"\n                : \"\";\n            const parentAlias = joinAttr.parentAlias;\n\n            // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\n            // table to join, without junction table involved. This means we simply join direct table.\n            if (!parentAlias || !relation) {\n                const destinationJoin = joinAttr.alias.subQuery\n                    ? joinAttr.alias.subQuery\n                    : this.getTableName(destinationTableName);\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    destinationJoin +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    (joinAttr.condition\n                        ? \" ON \" + this.replacePropertyNames(joinAttr.condition)\n                        : \"\")\n                );\n            }\n\n            // if real entity relation is involved\n            if (relation.isManyToOne || relation.isOneToOneOwner) {\n                // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\n                const condition = relation.joinColumns\n                    .map((joinColumn) => {\n                        return (\n                            destinationTableAlias +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath +\n                            \"=\" +\n                            parentAlias +\n                            \".\" +\n                            relation.propertyPath +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath\n                        );\n                    })\n                    .join(\" AND \");\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    \" ON \" +\n                    this.replacePropertyNames(condition + appendedCondition)\n                );\n            } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n                // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\n                const condition = relation\n                    .inverseRelation!.joinColumns.map((joinColumn) => {\n                        return (\n                            destinationTableAlias +\n                            \".\" +\n                            relation.inverseRelation!.propertyPath +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath +\n                            \"=\" +\n                            parentAlias +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath\n                        );\n                    })\n                    .join(\" AND \");\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    \" ON \" +\n                    this.replacePropertyNames(condition + appendedCondition)\n                );\n            } else {\n                // means many-to-many\n                const junctionTableName = relation.junctionEntityMetadata!\n                    .tablePath;\n\n                const junctionAlias = joinAttr.junctionAlias;\n                let junctionCondition = \"\",\n                    destinationCondition = \"\";\n\n                if (relation.isOwning) {\n                    junctionCondition = relation.joinColumns\n                        .map((joinColumn) => {\n                            // `post_category`.`postId` = `post`.`id`\n                            return (\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath +\n                                \"=\" +\n                                parentAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath\n                            );\n                        })\n                        .join(\" AND \");\n\n                    destinationCondition = relation.inverseJoinColumns\n                        .map((joinColumn) => {\n                            // `category`.`id` = `post_category`.`categoryId`\n                            return (\n                                destinationTableAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath +\n                                \"=\" +\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath\n                            );\n                        })\n                        .join(\" AND \");\n                } else {\n                    junctionCondition = relation\n                        .inverseRelation!.inverseJoinColumns.map(\n                            (joinColumn) => {\n                                // `post_category`.`categoryId` = `category`.`id`\n                                return (\n                                    junctionAlias +\n                                    \".\" +\n                                    joinColumn.propertyPath +\n                                    \"=\" +\n                                    parentAlias +\n                                    \".\" +\n                                    joinColumn.referencedColumn!.propertyPath\n                                );\n                            }\n                        )\n                        .join(\" AND \");\n\n                    destinationCondition = relation\n                        .inverseRelation!.joinColumns.map((joinColumn) => {\n                            // `post`.`id` = `post_category`.`postId`\n                            return (\n                                destinationTableAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath +\n                                \"=\" +\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath\n                            );\n                        })\n                        .join(\" AND \");\n                }\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(junctionTableName) +\n                    \" \" +\n                    this.escape(junctionAlias) +\n                    \" ON \" +\n                    this.replacePropertyNames(junctionCondition) +\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    \" ON \" +\n                    this.replacePropertyNames(\n                        destinationCondition + appendedCondition\n                    )\n                );\n            }\n        });\n\n        return joins.join(\" \");\n    }\n\n    /**\n     * Creates \"GROUP BY\" part of SQL query.\n     */\n    protected createGroupByExpression() {\n        if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length)\n            return \"\";\n        return (\n            \" GROUP BY \" +\n            this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"))\n        );\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n        const orderBys = this.expressionMap.allOrderBys;\n        if (Object.keys(orderBys).length > 0)\n            return (\n                \" ORDER BY \" +\n                Object.keys(orderBys)\n                    .map((columnName) => {\n                        if (typeof orderBys[columnName] === \"string\") {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                orderBys[columnName]\n                            );\n                        } else {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                (orderBys[columnName] as any).order +\n                                \" \" +\n                                (orderBys[columnName] as any).nulls\n                            );\n                        }\n                    })\n                    .join(\", \")\n            );\n\n        return \"\";\n    }\n\n    /**\n     * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\n     */\n    protected createLimitOffsetExpression(): string {\n        // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\n        // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\n        let offset: number | undefined = this.expressionMap.offset,\n            limit: number | undefined = this.expressionMap.limit;\n        if (\n            !offset &&\n            !limit &&\n            this.expressionMap.joinAttributes.length === 0\n        ) {\n            offset = this.expressionMap.skip;\n            limit = this.expressionMap.take;\n        }\n\n        if (this.connection.driver instanceof SqlServerDriver) {\n            // Due to a limitation in SQL Server's parser implementation it does not support using\n            // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the\n            // user does not request one we insert a dummy ORDER BY that does nothing and should\n            // have no effect on the query planner or on the order of the results returned.\n            // https://dba.stackexchange.com/a/193799\n            let prefix = \"\";\n            if (\n                (limit || offset) &&\n                Object.keys(this.expressionMap.allOrderBys).length <= 0\n            ) {\n                prefix = \" ORDER BY (SELECT NULL)\";\n            }\n\n            if (limit && offset)\n                return (\n                    prefix +\n                    \" OFFSET \" +\n                    offset +\n                    \" ROWS FETCH NEXT \" +\n                    limit +\n                    \" ROWS ONLY\"\n                );\n            if (limit)\n                return (\n                    prefix + \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\"\n                );\n            if (offset) return prefix + \" OFFSET \" + offset + \" ROWS\";\n        } else if (\n            this.connection.driver instanceof MysqlDriver ||\n            this.connection.driver instanceof AuroraDataApiDriver ||\n            this.connection.driver instanceof SapDriver\n        ) {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit) return \" LIMIT \" + limit;\n            if (offset) throw new OffsetWithoutLimitNotSupportedError();\n        } else if (this.connection.driver instanceof AbstractSqliteDriver) {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit) return \" LIMIT \" + limit;\n            if (offset) return \" LIMIT -1 OFFSET \" + offset;\n        } else if (this.connection.driver instanceof OracleDriver) {\n            if (limit && offset)\n                return (\n                    \" OFFSET \" +\n                    offset +\n                    \" ROWS FETCH NEXT \" +\n                    limit +\n                    \" ROWS ONLY\"\n                );\n            if (limit) return \" FETCH NEXT \" + limit + \" ROWS ONLY\";\n            if (offset) return \" OFFSET \" + offset + \" ROWS\";\n        } else {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit) return \" LIMIT \" + limit;\n            if (offset) return \" OFFSET \" + offset;\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Creates \"LOCK\" part of SQL query.\n     */\n    protected createLockExpression(): string {\n        const driver = this.connection.driver;\n        switch (this.expressionMap.lockMode) {\n            case \"pessimistic_read\":\n                if (\n                    driver instanceof MysqlDriver ||\n                    driver instanceof AuroraDataApiDriver\n                ) {\n                    return \" LOCK IN SHARE MODE\";\n                } else if (driver instanceof PostgresDriver) {\n                    return \" FOR SHARE\";\n                } else if (driver instanceof OracleDriver) {\n                    return \" FOR UPDATE\";\n                } else if (driver instanceof SqlServerDriver) {\n                    return \"\";\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_write\":\n                if (\n                    driver instanceof MysqlDriver ||\n                    driver instanceof AuroraDataApiDriver ||\n                    driver instanceof PostgresDriver ||\n                    driver instanceof OracleDriver\n                ) {\n                    return \" FOR UPDATE\";\n                } else if (driver instanceof SqlServerDriver) {\n                    return \"\";\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_partial_write\":\n                if (driver instanceof PostgresDriver) {\n                    return \" FOR UPDATE SKIP LOCKED\";\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_write_or_fail\":\n                if (driver instanceof PostgresDriver) {\n                    return \" FOR UPDATE NOWAIT\";\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n\n            case \"for_no_key_update\":\n                if (driver instanceof PostgresDriver) {\n                    return \" FOR NO KEY UPDATE\";\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            default:\n                return \"\";\n        }\n    }\n\n    /**\n     * Creates \"HAVING\" part of SQL query.\n     */\n    protected createHavingExpression() {\n        if (!this.expressionMap.havings || !this.expressionMap.havings.length)\n            return \"\";\n        const conditions = this.expressionMap.havings\n            .map((having, index) => {\n                switch (having.type) {\n                    case \"and\":\n                        return (\n                            (index > 0 ? \"AND \" : \"\") +\n                            this.replacePropertyNames(having.condition)\n                        );\n                    case \"or\":\n                        return (\n                            (index > 0 ? \"OR \" : \"\") +\n                            this.replacePropertyNames(having.condition)\n                        );\n                    default:\n                        return this.replacePropertyNames(having.condition);\n                }\n            })\n            .join(\" \");\n\n        if (!conditions.length) return \"\";\n        return \" HAVING \" + conditions;\n    }\n\n    protected buildEscapedEntityColumnSelects(\n        aliasName: string,\n        metadata: EntityMetadata\n    ): SelectQuery[] {\n        const hasMainAlias = this.expressionMap.selects.some(\n            (select) => select.selection === aliasName\n        );\n\n        const columns: ColumnMetadata[] = [];\n        if (hasMainAlias) {\n            columns.push(\n                ...metadata.columns.filter((column) => column.isSelect === true)\n            );\n        }\n        columns.push(\n            ...metadata.columns.filter((column) => {\n                return this.expressionMap.selects.some(\n                    (select) =>\n                        select.selection ===\n                        aliasName + \".\" + column.propertyPath\n                );\n            })\n        );\n\n        // if user used partial selection and did not select some primary columns which are required to be selected\n        // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\n        // to make entity contain exactly what user selected\n        if (columns.length === 0)\n            // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)\n            return [];\n\n        const nonSelectedPrimaryColumns = this.expressionMap.queryEntity\n            ? metadata.primaryColumns.filter(\n                  (primaryColumn) => columns.indexOf(primaryColumn) === -1\n              )\n            : [];\n        const allColumns = [...columns, ...nonSelectedPrimaryColumns];\n\n        return allColumns.map((column) => {\n            const selection = this.expressionMap.selects.find(\n                (select) =>\n                    select.selection === aliasName + \".\" + column.propertyPath\n            );\n            let selectionPath =\n                this.escape(aliasName) + \".\" + this.escape(column.databaseName);\n            if (\n                this.connection.driver.spatialTypes.indexOf(column.type) !== -1\n            ) {\n                if (\n                    this.connection.driver instanceof MysqlDriver ||\n                    this.connection.driver instanceof AuroraDataApiDriver\n                ) {\n                    const useLegacy = this.connection.driver.options\n                        .legacySpatialSupport;\n                    const asText = useLegacy ? \"AsText\" : \"ST_AsText\";\n                    selectionPath = `${asText}(${selectionPath})`;\n                }\n\n                if (this.connection.driver instanceof PostgresDriver)\n                    // cast to JSON to trigger parsing in the driver\n                    selectionPath = `ST_AsGeoJSON(${selectionPath})::json`;\n\n                if (this.connection.driver instanceof SqlServerDriver)\n                    selectionPath = `${selectionPath}.ToString()`;\n            }\n\n            if (\n                column.type === \"json\" &&\n                this.connection.driver instanceof DB2Driver\n            ) {\n                selectionPath = `SYSTOOLS.BSON2JSON(${selectionPath})`;\n            }\n\n            return {\n                selection: selectionPath,\n                aliasName:\n                    selection && selection.aliasName\n                        ? selection.aliasName\n                        : DriverUtils.buildColumnAlias(\n                              this.connection.driver,\n                              aliasName,\n                              column.databaseName\n                          ),\n                // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n                virtual: selection\n                    ? selection.virtual === true\n                    : hasMainAlias\n                    ? false\n                    : true,\n            };\n        });\n    }\n\n    protected findEntityColumnSelects(\n        aliasName: string,\n        metadata: EntityMetadata\n    ): SelectQuery[] {\n        const mainSelect = this.expressionMap.selects.find(\n            (select) => select.selection === aliasName\n        );\n        if (mainSelect) return [mainSelect];\n\n        return this.expressionMap.selects.filter((select) => {\n            return metadata.columns.some(\n                (column) =>\n                    select.selection === aliasName + \".\" + column.propertyPath\n            );\n        });\n    }\n\n    private computeCountExpression() {\n        const mainAlias = this.expressionMap.mainAlias!.name; // todo: will this work with \"fromTableName\"?\n        const metadata = this.expressionMap.mainAlias!.metadata;\n\n        const primaryColumns = metadata.primaryColumns;\n        const distinctAlias = this.escape(mainAlias);\n\n        // If we aren't doing anything that will create a join, we can use a simpler `COUNT` instead\n        // so we prevent poor query patterns in the most likely cases\n        if (\n            this.expressionMap.joinAttributes.length === 0 &&\n            this.expressionMap.relationIdAttributes.length === 0 &&\n            this.expressionMap.relationCountAttributes.length === 0\n        ) {\n            return \"COUNT(1)\";\n        }\n\n        // For everything else, we'll need to do some hackery to get the correct count values.\n\n        if (\n            this.connection.driver instanceof CockroachDriver ||\n            this.connection.driver instanceof PostgresDriver\n        ) {\n            // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function\n            // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT\n            return (\n                \"COUNT(DISTINCT(\" +\n                primaryColumns\n                    .map(\n                        (c) => `${distinctAlias}.${this.escape(c.databaseName)}`\n                    )\n                    .join(\", \") +\n                \"))\"\n            );\n        }\n\n        if (this.connection.driver instanceof MysqlDriver) {\n            // MySQL & MariaDB can pass multiple parameters to the `DISTINCT` language construct\n            // https://mariadb.com/kb/en/count-distinct/\n            return (\n                \"COUNT(DISTINCT \" +\n                primaryColumns\n                    .map(\n                        (c) => `${distinctAlias}.${this.escape(c.databaseName)}`\n                    )\n                    .join(\", \") +\n                \")\"\n            );\n        }\n\n        if (this.connection.driver instanceof SqlServerDriver) {\n            // SQL Server has gotta be different from everyone else.  They don't support\n            // distinct counting multiple columns & they don't have the same operator\n            // characteristic for concatenating, so we gotta use the `CONCAT` function.\n            // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.\n\n            const columnsExpression = primaryColumns\n                .map(\n                    (primaryColumn) =>\n                        `${distinctAlias}.${this.escape(\n                            primaryColumn.databaseName\n                        )}`\n                )\n                .join(\", '|;|', \");\n\n            if (primaryColumns.length === 1) {\n                return `COUNT(DISTINCT(${columnsExpression}))`;\n            }\n\n            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;\n        }\n\n        // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.\n        // Per the SQL spec, this is the canonical string concatenation mechanism which is most\n        // likely to work across servers implementing the SQL standard.\n\n        // Please note, if there is only one primary column that the concatenation does not occur in this\n        // query and the query is a standard `COUNT DISTINCT` in that case.\n\n        return (\n            `COUNT(DISTINCT(` +\n            primaryColumns\n                .map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`)\n                .join(\" || '|;|' || \") +\n            \"))\"\n        );\n    }\n\n    protected async executeCountQuery(\n        queryRunner: QueryRunner\n    ): Promise<number> {\n        const countSql = this.computeCountExpression();\n\n        const results = await this.clone()\n            .orderBy()\n            .groupBy()\n            .offset(undefined)\n            .limit(undefined)\n            .skip(undefined)\n            .take(undefined)\n            .select(countSql, \"cnt\")\n            .setOption(\"disable-global-order\")\n            .loadRawResults(queryRunner);\n\n        if (!results || !results[0] || !results[0][\"cnt\"]) return 0;\n\n        return parseInt(results[0][\"cnt\"]);\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    protected async executeEntitiesAndRawResults(\n        queryRunner: QueryRunner\n    ): Promise<{ entities: Entity[]; raw: any[] }> {\n        if (!this.expressionMap.mainAlias)\n            throw new Error(\n                `Alias is not set. Use \"from\" method to set an alias.`\n            );\n\n        if (\n            (this.expressionMap.lockMode === \"pessimistic_read\" ||\n                this.expressionMap.lockMode === \"pessimistic_write\" ||\n                this.expressionMap.lockMode === \"pessimistic_partial_write\" ||\n                this.expressionMap.lockMode === \"pessimistic_write_or_fail\" ||\n                this.expressionMap.lockMode === \"for_no_key_update\") &&\n            !queryRunner.isTransactionActive\n        )\n            throw new PessimisticLockTransactionRequiredError();\n\n        if (this.expressionMap.lockMode === \"optimistic\") {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            if (!metadata.versionColumn && !metadata.updateDateColumn)\n                throw new NoVersionOrUpdateDateColumnError(metadata.name);\n        }\n\n        const relationIdLoader = new RelationIdLoader(\n            this.connection,\n            queryRunner,\n            this.expressionMap.relationIdAttributes\n        );\n        const relationCountLoader = new RelationCountLoader(\n            this.connection,\n            queryRunner,\n            this.expressionMap.relationCountAttributes\n        );\n        const relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer(\n            this.expressionMap\n        );\n        relationIdMetadataTransformer.transform();\n        const relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer(\n            this.expressionMap\n        );\n        relationCountMetadataTransformer.transform();\n\n        let rawResults: any[] = [],\n            entities: any[] = [];\n\n        // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\n        // where we make two queries to find the data we need\n        // first query find ids in skip and take range\n        // and second query loads the actual data in given ids range\n        if (\n            (this.expressionMap.skip || this.expressionMap.take) &&\n            this.expressionMap.joinAttributes.length > 0\n        ) {\n            // we are skipping order by here because its not working in subqueries anyway\n            // to make order by working we need to apply it on a distinct query\n            const [\n                selects,\n                orderBys,\n            ] = this.createOrderByCombinedWithSelectExpression(\"distinctAlias\");\n            const metadata = this.expressionMap.mainAlias.metadata;\n            const mainAliasName = this.expressionMap.mainAlias.name;\n\n            const querySelects = metadata.primaryColumns.map(\n                (primaryColumn) => {\n                    const distinctAlias = this.escape(\"distinctAlias\");\n                    const columnAlias = this.escape(\n                        DriverUtils.buildColumnAlias(\n                            this.connection.driver,\n                            mainAliasName,\n                            primaryColumn.databaseName\n                        )\n                    );\n                    if (!orderBys[columnAlias])\n                        // make sure we aren't overriding user-defined order in inverse direction\n                        orderBys[columnAlias] = \"ASC\";\n\n                    const alias = DriverUtils.buildColumnAlias(\n                        this.connection.driver,\n                        \"ids_\" + mainAliasName,\n                        primaryColumn.databaseName\n                    );\n\n                    return `${distinctAlias}.${columnAlias} as \"${alias}\"`;\n                }\n            );\n\n            rawResults = await new SelectQueryBuilder(\n                this.connection,\n                queryRunner\n            )\n                .select(`DISTINCT ${querySelects.join(\", \")}`)\n                .addSelect(selects)\n                .from(`(${this.clone().orderBy().getQuery()})`, \"distinctAlias\")\n                .offset(this.expressionMap.skip)\n                .limit(this.expressionMap.take)\n                .orderBy(orderBys)\n                .cache(\n                    this.expressionMap.cache\n                        ? this.expressionMap.cache\n                        : this.expressionMap.cacheId,\n                    this.expressionMap.cacheDuration\n                )\n                .setParameters(this.getParameters())\n                .setNativeParameters(this.expressionMap.nativeParameters)\n                .getRawMany();\n\n            if (rawResults.length > 0) {\n                let condition = \"\";\n                const parameters: ObjectLiteral = {};\n                if (metadata.hasMultiplePrimaryKeys) {\n                    condition = rawResults\n                        .map((result, index) => {\n                            return metadata.primaryColumns\n                                .map((primaryColumn) => {\n                                    const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`;\n                                    parameters[paramKey] =\n                                        result[\n                                            `ids_${mainAliasName}_${primaryColumn.databaseName}`\n                                        ];\n                                    return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`;\n                                })\n                                .join(\" AND \");\n                        })\n                        .join(\" OR \");\n                } else {\n                    const alias = DriverUtils.buildColumnAlias(\n                        this.connection.driver,\n                        \"ids_\" + mainAliasName,\n                        metadata.primaryColumns[0].databaseName\n                    );\n\n                    const ids = rawResults.map((result) => result[alias]);\n                    const areAllNumbers = ids.every(\n                        (id: any) => typeof id === \"number\"\n                    );\n                    if (areAllNumbers) {\n                        // fixes #190. if all numbers then its safe to perform query without parameter\n                        condition = `${mainAliasName}.${\n                            metadata.primaryColumns[0].propertyPath\n                        } IN (${ids.join(\", \")})`;\n                    } else {\n                        parameters[\"orm_distinct_ids\"] = ids;\n                        condition =\n                            mainAliasName +\n                            \".\" +\n                            metadata.primaryColumns[0].propertyPath +\n                            \" IN (:...orm_distinct_ids)\";\n                    }\n                }\n                rawResults = await this.clone()\n                    .mergeExpressionMap({\n                        extraAppendedAndWhereCondition: condition,\n                    })\n                    .setParameters(parameters)\n                    .loadRawResults(queryRunner);\n            }\n        } else {\n            rawResults = await this.loadRawResults(queryRunner);\n        }\n\n        if (rawResults.length > 0) {\n            // transform raw results into entities\n            const rawRelationIdResults = await relationIdLoader.load(\n                rawResults\n            );\n            const rawRelationCountResults = await relationCountLoader.load(\n                rawResults\n            );\n            const transformer = new RawSqlResultsToEntityTransformer(\n                this.expressionMap,\n                this.connection.driver,\n                rawRelationIdResults,\n                rawRelationCountResults,\n                this.queryRunner\n            );\n            entities = transformer.transform(\n                rawResults,\n                this.expressionMap.mainAlias!\n            );\n\n            // broadcast all \"after load\" events\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias.hasMetadata\n            ) {\n                const broadcastResult = new BroadcasterResult();\n                queryRunner.broadcaster.broadcastLoadEventsForAll(\n                    broadcastResult,\n                    this.expressionMap.mainAlias.metadata,\n                    entities\n                );\n                if (broadcastResult.promises.length > 0)\n                    await Promise.all(broadcastResult.promises);\n            }\n        }\n\n        return {\n            raw: rawResults,\n            entities: entities,\n        };\n    }\n\n    protected createOrderByCombinedWithSelectExpression(\n        parentAlias: string\n    ): [string, OrderByCondition] {\n        // if table has a default order then apply it\n        const orderBys = this.expressionMap.allOrderBys;\n        const selectString = Object.keys(orderBys)\n            .map((orderCriteria) => {\n                if (orderCriteria.indexOf(\".\") !== -1) {\n                    const [aliasName, propertyPath] = orderCriteria.split(\".\");\n                    const alias = this.expressionMap.findAliasByName(aliasName);\n                    const column = alias.metadata.findColumnWithPropertyName(\n                        propertyPath\n                    );\n                    return (\n                        this.escape(parentAlias) +\n                        \".\" +\n                        this.escape(\n                            DriverUtils.buildColumnAlias(\n                                this.connection.driver,\n                                aliasName,\n                                column!.databaseName\n                            )\n                        )\n                    );\n                } else {\n                    if (\n                        this.expressionMap.selects.find(\n                            (select) =>\n                                select.selection === orderCriteria ||\n                                select.aliasName === orderCriteria\n                        )\n                    )\n                        return this.escape(parentAlias) + \".\" + orderCriteria;\n\n                    return \"\";\n                }\n            })\n            .join(\", \");\n\n        const orderByObject: OrderByCondition = {};\n        Object.keys(orderBys).forEach((orderCriteria) => {\n            if (orderCriteria.indexOf(\".\") !== -1) {\n                const [aliasName, propertyPath] = orderCriteria.split(\".\");\n                const alias = this.expressionMap.findAliasByName(aliasName);\n                const column = alias.metadata.findColumnWithPropertyName(\n                    propertyPath\n                );\n                orderByObject[\n                    this.escape(parentAlias) +\n                        \".\" +\n                        this.escape(\n                            DriverUtils.buildColumnAlias(\n                                this.connection.driver,\n                                aliasName,\n                                column!.databaseName\n                            )\n                        )\n                ] = orderBys[orderCriteria];\n            } else {\n                if (\n                    this.expressionMap.selects.find(\n                        (select) =>\n                            select.selection === orderCriteria ||\n                            select.aliasName === orderCriteria\n                    )\n                ) {\n                    orderByObject[\n                        this.escape(parentAlias) + \".\" + orderCriteria\n                    ] = orderBys[orderCriteria];\n                } else {\n                    orderByObject[orderCriteria] = orderBys[orderCriteria];\n                }\n            }\n        });\n\n        return [selectString, orderByObject];\n    }\n\n    /**\n     * Loads raw results from the database.\n     */\n    protected async loadRawResults(queryRunner: QueryRunner) {\n        const [sql, parameters] = this.getQueryAndParameters();\n        const queryId = sql + \" -- PARAMETERS: \" + JSON.stringify(parameters);\n        const cacheOptions =\n            typeof this.connection.options.cache === \"object\"\n                ? this.connection.options.cache\n                : {};\n        let savedQueryResultCacheOptions:\n            | QueryResultCacheOptions\n            | undefined = undefined;\n        if (\n            this.connection.queryResultCache &&\n            (this.expressionMap.cache || cacheOptions.alwaysEnabled)\n        ) {\n            savedQueryResultCacheOptions = await this.connection.queryResultCache.getFromCache(\n                {\n                    identifier: this.expressionMap.cacheId,\n                    query: queryId,\n                    duration:\n                        this.expressionMap.cacheDuration ||\n                        cacheOptions.duration ||\n                        1000,\n                },\n                queryRunner\n            );\n            if (\n                savedQueryResultCacheOptions &&\n                !this.connection.queryResultCache.isExpired(\n                    savedQueryResultCacheOptions\n                )\n            )\n                return JSON.parse(savedQueryResultCacheOptions.result);\n        }\n\n        const results = await queryRunner.query(sql, parameters);\n\n        if (\n            this.connection.queryResultCache &&\n            (this.expressionMap.cache || cacheOptions.alwaysEnabled)\n        ) {\n            await this.connection.queryResultCache.storeInCache(\n                {\n                    identifier: this.expressionMap.cacheId,\n                    query: queryId,\n                    time: new Date().getTime(),\n                    duration:\n                        this.expressionMap.cacheDuration ||\n                        cacheOptions.duration ||\n                        1000,\n                    result: JSON.stringify(results),\n                },\n                savedQueryResultCacheOptions,\n                queryRunner\n            );\n        }\n\n        return results;\n    }\n\n    /**\n     * Merges into expression map given expression map properties.\n     */\n    protected mergeExpressionMap(\n        expressionMap: Partial<QueryExpressionMap>\n    ): this {\n        ObjectUtils.assign(this.expressionMap, expressionMap);\n        return this;\n    }\n\n    /**\n     * Normalizes a give number - converts to int if possible.\n     */\n    protected normalizeNumber(num: any) {\n        if (typeof num === \"number\" || num === undefined || num === null)\n            return num;\n\n        return Number(num);\n    }\n\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    protected obtainQueryRunner() {\n        return this.queryRunner || this.connection.createQueryRunner(\"slave\");\n    }\n}\n"],"sourceRoot":".."}