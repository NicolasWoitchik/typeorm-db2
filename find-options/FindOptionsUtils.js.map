{"version":3,"sources":["../../src/find-options/FindOptionsUtils.ts"],"names":[],"mappings":"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","file":"FindOptionsUtils.js","sourcesContent":["import { FindManyOptions } from \"./FindManyOptions\";\nimport { FindOneOptions } from \"./FindOneOptions\";\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\";\nimport { FindRelationsNotFoundError } from \"../error/FindRelationsNotFoundError\";\nimport { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { shorten } from \"../util/StringUtils\";\n\n/**\n * Utilities to work with FindOptions.\n */\nexport class FindOptionsUtils {\n    // -------------------------------------------------------------------------\n    // Public Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if given object is really instance of FindOneOptions interface.\n     */\n    static isFindOneOptions<Entity = any>(\n        obj: any\n    ): obj is FindOneOptions<Entity> {\n        const possibleOptions: FindOneOptions<Entity> = obj;\n        return (\n            possibleOptions &&\n            (Array.isArray(possibleOptions.select) ||\n                possibleOptions.where instanceof Object ||\n                typeof possibleOptions.where === \"string\" ||\n                Array.isArray(possibleOptions.relations) ||\n                possibleOptions.join instanceof Object ||\n                possibleOptions.order instanceof Object ||\n                possibleOptions.cache instanceof Object ||\n                typeof possibleOptions.cache === \"boolean\" ||\n                typeof possibleOptions.cache === \"number\" ||\n                possibleOptions.lock instanceof Object ||\n                possibleOptions.loadRelationIds instanceof Object ||\n                typeof possibleOptions.loadRelationIds === \"boolean\" ||\n                typeof possibleOptions.loadEagerRelations === \"boolean\" ||\n                typeof possibleOptions.withDeleted === \"boolean\" ||\n                typeof possibleOptions.transaction === \"boolean\")\n        );\n    }\n\n    /**\n     * Checks if given object is really instance of FindManyOptions interface.\n     */\n    static isFindManyOptions<Entity = any>(\n        obj: any\n    ): obj is FindManyOptions<Entity> {\n        const possibleOptions: FindManyOptions<Entity> = obj;\n        return (\n            possibleOptions &&\n            (this.isFindOneOptions(possibleOptions) ||\n                typeof (possibleOptions as FindManyOptions<any>).skip ===\n                    \"number\" ||\n                typeof (possibleOptions as FindManyOptions<any>).take ===\n                    \"number\" ||\n                typeof (possibleOptions as FindManyOptions<any>).skip ===\n                    \"string\" ||\n                typeof (possibleOptions as FindManyOptions<any>).take ===\n                    \"string\")\n        );\n    }\n\n    /**\n     * Checks if given object is really instance of FindOptions interface.\n     */\n    static extractFindManyOptionsAlias(object: any): string | undefined {\n        if (this.isFindManyOptions(object) && object.join)\n            return object.join.alias;\n\n        return undefined;\n    }\n\n    /**\n     * Applies give find many options to the given query builder.\n     */\n    static applyFindManyOptionsOrConditionsToQueryBuilder<T>(\n        qb: SelectQueryBuilder<T>,\n        options: FindManyOptions<T> | Partial<T> | undefined\n    ): SelectQueryBuilder<T> {\n        if (this.isFindManyOptions(options))\n            return this.applyOptionsToQueryBuilder(qb, options);\n\n        if (options) return qb.where(options);\n\n        return qb;\n    }\n\n    /**\n     * Applies give find options to the given query builder.\n     */\n    static applyOptionsToQueryBuilder<T>(\n        qb: SelectQueryBuilder<T>,\n        options: FindOneOptions<T> | FindManyOptions<T> | undefined\n    ): SelectQueryBuilder<T> {\n        // if options are not set then simply return query builder. This is made for simplicity of usage.\n        if (\n            !options ||\n            (!this.isFindOneOptions(options) &&\n                !this.isFindManyOptions(options))\n        )\n            return qb;\n\n        if (options.transaction === true) {\n            qb.expressionMap.useTransaction = true;\n        }\n\n        if (\n            !qb.expressionMap.mainAlias ||\n            !qb.expressionMap.mainAlias.hasMetadata\n        )\n            return qb;\n\n        const metadata = qb.expressionMap.mainAlias!.metadata;\n\n        // apply all options from FindOptions\n        if (options.select) {\n            qb.select([]);\n            options.select.forEach((select) => {\n                if (!metadata.findColumnWithPropertyPath(String(select)))\n                    throw new Error(\n                        `${select} column was not found in the ${metadata.name} entity.`\n                    );\n\n                qb.addSelect(qb.alias + \".\" + select);\n            });\n        }\n\n        if (options.where) qb.where(options.where);\n\n        if ((options as FindManyOptions<T>).skip)\n            qb.skip((options as FindManyOptions<T>).skip!);\n\n        if ((options as FindManyOptions<T>).take)\n            qb.take((options as FindManyOptions<T>).take!);\n\n        if (options.order)\n            Object.keys(options.order).forEach((key) => {\n                const order = ((options as FindOneOptions<T>).order as any)[\n                    key as any\n                ];\n\n                if (!metadata.findColumnWithPropertyPath(key))\n                    throw new Error(\n                        `${key} column was not found in the ${metadata.name} entity.`\n                    );\n\n                switch (order) {\n                    case 1:\n                        qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n                        break;\n                    case -1:\n                        qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n                        break;\n                    case \"ASC\":\n                        qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n                        break;\n                    case \"DESC\":\n                        qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n                        break;\n                }\n            });\n\n        if (options.relations) {\n            const allRelations = options.relations.map((relation) => relation);\n            this.applyRelationsRecursively(\n                qb,\n                allRelations,\n                qb.expressionMap.mainAlias!.name,\n                qb.expressionMap.mainAlias!.metadata,\n                \"\"\n            );\n            // recursive removes found relations from allRelations array\n            // if there are relations left in this array it means those relations were not found in the entity structure\n            // so, we give an exception about not found relations\n            if (allRelations.length > 0)\n                throw new FindRelationsNotFoundError(allRelations);\n        }\n\n        if (options.join) {\n            if (options.join.leftJoin)\n                Object.keys(options.join.leftJoin).forEach((key) => {\n                    qb.leftJoin(options.join!.leftJoin![key], key);\n                });\n\n            if (options.join.innerJoin)\n                Object.keys(options.join.innerJoin).forEach((key) => {\n                    qb.innerJoin(options.join!.innerJoin![key], key);\n                });\n\n            if (options.join.leftJoinAndSelect)\n                Object.keys(options.join.leftJoinAndSelect).forEach((key) => {\n                    qb.leftJoinAndSelect(\n                        options.join!.leftJoinAndSelect![key],\n                        key\n                    );\n                });\n\n            if (options.join.innerJoinAndSelect)\n                Object.keys(options.join.innerJoinAndSelect).forEach((key) => {\n                    qb.innerJoinAndSelect(\n                        options.join!.innerJoinAndSelect![key],\n                        key\n                    );\n                });\n        }\n\n        if (options.cache) {\n            if (options.cache instanceof Object) {\n                const cache = options.cache as {\n                    id: any;\n                    milliseconds: number;\n                };\n                qb.cache(cache.id, cache.milliseconds);\n            } else {\n                qb.cache(options.cache);\n            }\n        }\n\n        if (options.lock) {\n            if (options.lock.mode === \"optimistic\") {\n                qb.setLock(options.lock.mode, options.lock.version as any);\n            } else if (\n                options.lock.mode === \"pessimistic_read\" ||\n                options.lock.mode === \"pessimistic_write\" ||\n                options.lock.mode === \"dirty_read\" ||\n                options.lock.mode === \"pessimistic_partial_write\" ||\n                options.lock.mode === \"pessimistic_write_or_fail\"\n            ) {\n                qb.setLock(options.lock.mode);\n            }\n        }\n\n        if (options.withDeleted) {\n            qb.withDeleted();\n        }\n\n        if (options.loadRelationIds === true) {\n            qb.loadAllRelationIds();\n        } else if (options.loadRelationIds instanceof Object) {\n            qb.loadAllRelationIds(options.loadRelationIds as any);\n        }\n\n        return qb;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds joins for all relations and sub-relations of the given relations provided in the find options.\n     */\n    protected static applyRelationsRecursively(\n        qb: SelectQueryBuilder<any>,\n        allRelations: string[],\n        alias: string,\n        metadata: EntityMetadata,\n        prefix: string\n    ): void {\n        // find all relations that match given prefix\n        let matchedBaseRelations: string[] = [];\n        if (prefix) {\n            const regexp = new RegExp(\"^\" + prefix.replace(\".\", \"\\\\.\") + \"\\\\.\");\n            matchedBaseRelations = allRelations\n                .filter((relation) => relation.match(regexp))\n                .map((relation) => relation.replace(regexp, \"\"))\n                .filter((relation) =>\n                    metadata.findRelationWithPropertyPath(relation)\n                );\n        } else {\n            matchedBaseRelations = allRelations.filter((relation) =>\n                metadata.findRelationWithPropertyPath(relation)\n            );\n        }\n\n        // go through all matched relations and add join for them\n        matchedBaseRelations.forEach((relation) => {\n            // generate a relation alias\n            let relationAlias: string = alias + \"__\" + relation;\n            // shorten it if needed by the driver\n            if (\n                qb.connection.driver.maxAliasLength &&\n                relationAlias.length > qb.connection.driver.maxAliasLength\n            ) {\n                relationAlias = shorten(relationAlias);\n            }\n\n            // add a join for the found relation\n            const selection = alias + \".\" + relation;\n            qb.leftJoinAndSelect(selection, relationAlias);\n\n            // join the eager relations of the found relation\n            const relMetadata = metadata.relations.find(\n                (metadata) => metadata.propertyName === relation\n            );\n            if (relMetadata) {\n                this.joinEagerRelations(\n                    qb,\n                    relationAlias,\n                    relMetadata.inverseEntityMetadata\n                );\n            }\n\n            // remove added relations from the allRelations array, this is needed to find all not found relations at the end\n            allRelations.splice(\n                allRelations.indexOf(\n                    prefix ? prefix + \".\" + relation : relation\n                ),\n                1\n            );\n\n            // try to find sub-relations\n            const join = qb.expressionMap.joinAttributes.find(\n                (join) => join.entityOrProperty === selection\n            );\n            this.applyRelationsRecursively(\n                qb,\n                allRelations,\n                join!.alias.name,\n                join!.metadata!,\n                prefix ? prefix + \".\" + relation : relation\n            );\n        });\n    }\n\n    public static joinEagerRelations(\n        qb: SelectQueryBuilder<any>,\n        alias: string,\n        metadata: EntityMetadata\n    ) {\n        metadata.eagerRelations.forEach((relation) => {\n            const relationAlias = qb.connection.namingStrategy.eagerJoinRelationAlias(\n                alias,\n                relation.propertyPath\n            );\n            qb.leftJoinAndSelect(\n                alias + \".\" + relation.propertyPath,\n                relationAlias\n            );\n            this.joinEagerRelations(\n                qb,\n                relationAlias,\n                relation.inverseEntityMetadata\n            );\n        });\n    }\n}\n"],"sourceRoot":".."}